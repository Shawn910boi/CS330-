# CS330-
*How do I approach designing software?
I begin with clearly defining the goal and user interaction—what should the user experience be? For this project, that meant creating an engaging 2D game that incorporated physics, interactivity, and progressive feedback through animations. I used iterative sketching and feature prioritization to guide the layout and behavior of bricks, balls, and paddle controls.
*What new design skills has your work on the project helped you to craft?
Through this project, I developed a deeper understanding of how visual elements (like color and shape) can reflect game state, such as a brick cracking after each hit. I also learned how to layer interactivity (multiple balls, paddle mechanics) in a way that feels intuitive to the player.
*What design process did you follow for your project work?
I used an iterative design approach: start simple, test functionality, then enhance. For example, I began with a single ball and paddle, then added more complex interactions such as multiple balls and changing brick durability with visual feedback.
*How could tactics from your design approach be applied in future work?
This project reinforced that prototyping and user testing are crucial. In the future, I’ll continue applying iterative design cycles—starting with MVPs (minimum viable products), testing core logic, and layering features thoughtfully.
*How do I approach developing programs?
I break problems into manageable systems: object creation, movement, collision detection, and rendering. Then I implement and test one module at a time. For example, I built Ball, Brick, and Paddle classes with encapsulated logic and drew connections between them through physics updates.
*What new development strategies did you use while working on your 3D/2D scene?
I learned to manage complex object interactions using std::vector to handle dynamic entities like multiple balls. I also improved debugging skills by visualizing values (like position and velocity) and testing edge cases (balls getting stuck or lost off-screen).
*How did iteration factor into your development?
Iteration was essential. After each change, I recompiled and tested frequently. For example, when implementing ball enlargement on collision, I adjusted the growth cap several times for gameplay balance.
*How has your approach to developing code evolved throughout the milestones, which led you to the project’s completion?
Initially, my focus was on just getting things to render. As I progressed, I shifted toward building reusable, maintainable code. I adopted cleaner structuring, used constants, and added more abstraction with classes. My confidence in handling OpenGL and physics logic also grew.
*How can computer science help me in reaching my goals?
Computer science trains me in problem-solving, logic, and abstraction—skills that are transferable to any tech-focused career. It empowers me to build real-world applications and simulations, whether in game design, data visualization, or software engineering.
*How do computational graphics and visualizations give you new knowledge and skills that can be applied in your future educational pathway?
Through computational graphics, I’ve learned about rendering pipelines, coordinate systems, and interactive animation, which strengthens my understanding of both theory and implementation. These skills prepare me for advanced courses in simulation, AI, or 3D modeling.
*How do computational graphics and visualizations give you new knowledge and skills that can be applied in your future professional pathway?
Professionally, these skills open paths in game development, UI/UX design, and even data visualization. Knowing how to animate, simulate, and interact with digital objects gives me an edge in any role that involves front-end development or interactive technologies.
